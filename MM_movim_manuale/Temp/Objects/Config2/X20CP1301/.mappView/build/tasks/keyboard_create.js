/*global module*/
module.exports = function (grunt) {

    'use strict';

    // node modules
    var _modulePath = require('path'),
        _moduleXml2js = require('xml2js'),
        _moduleRequire = require('a.require'),

        // xml/js converter
        _xmlBuilder = new _moduleXml2js.Builder({ headless: true }),
        _xmlConvert = {
            xml2js: _moduleXml2js.parseString,
            js2xml: _xmlBuilder.buildObject.bind(_xmlBuilder)
        },

        // global iat modules
        Utils = _moduleRequire('iat/utils'),
        DataTypes = _moduleRequire('iat/DataTypes'),
        Properties = _moduleRequire('iat/Properties'),
        debug = false;

    /**
    * @method keyboard_create
    * @param {String} srcFile path to keyboard widget xml input (e.g. "C:/dev/examples/NumPad.numpad")
    * @param {String} targetFolder directory to write to (e.g. "C:/projects/Trunk/WidgetTests/Logical/mappView/Widgets")
    * @param {String} corePath directory of brease core (e.g. "C:/Program Files/BrAutomation/AS45/AS/TechnologyPackages/mappView/5.8.0/IATC/BRVisu") 
    * @param {String} libraryName name of library of keyboard widget
    */
    grunt.registerTask('keyboard_create', 'task for creation of keyboard widgets', function (srcFile, targetFolder, corePath, libraryName) {

        // local iat modules
        var patchKeyboard = _moduleRequire('iat/libs/keyboard_patchObj'),
            keyboardJsPrepare = _moduleRequire('iat/libs/keyboard_jsPrepare'),
            xsdPrepare = _moduleRequire('iat/xsdPrepare'),
            styleParser = _moduleRequire('iat/styleParser'),
            json2xml = _moduleRequire('iat/json2xml'),
            xsltTrans = _moduleRequire('iat/XSLTTransformation'),
            jsPrepare = _moduleRequire('iat/jsPrepare'),
            elemValidator = _moduleRequire('iat/libs/keyboard_elementsValidator');
        targetFolder = (targetFolder && targetFolder !== 'null') ? targetFolder : _modulePath.resolve(grunt.config('wwwRoot'), '/BRVisu/widgets');
        corePath = (corePath && corePath !== 'null') ? corePath : _modulePath.resolve(grunt.config('basePath'), '../BRVisu');
        var coreWidgets = (corePath.indexOf('wwwRoot/BRVisu') !== -1) ? _modulePath.resolve(corePath, 'widgets') : _modulePath.resolve(corePath, '../../Widgets');

        if (debug) {
            grunt.log.writeln('srcFile:' + srcFile);
            grunt.log.writeln('targetFolder:' + targetFolder);
            grunt.log.writeln('corePath:' + corePath);
            grunt.log.writeln('libraryName:' + libraryName);
        }

        if (!libraryName) {
            grunt.fail.fatal('missing library name');
        }

        grunt.file.defaultEncoding = 'utf8';

        // read source xml file
        var xmlString = grunt.file.read(srcFile);

        // convert src xml to js object
        _xmlConvert.xml2js(xmlString, {
            trim: true
        }, function (errArg, xmlObj) {
            if (errArg !== null) {
                grunt.fail.fatal('Error at XML conversion: ' + errArg);
            }
            if (debug) {
                _writeFile(_modulePath.resolve('/Temp/mvLog/keyboardXML.json'), JSON.stringify(xmlObj));
            }
            if (xmlObj) {

                // xml of Keyboard as js object
                var keyboardType = (xmlObj['NumPad']) ? 'NumPad' : 'AlphaPad',
                    keyboardXML = xmlObj[keyboardType],
                    displayName = keyboardXML['$']['display'],
                    // keyboardWidget infos (path, name, type, properties, etc)
                    widgetObject = _widgetObject(keyboardXML, keyboardType, targetFolder, libraryName),
                    // base class (system.widgets.Keyboard or system.widgets.NumPad) widget info (path, name, etc)
                    baseClassObject = _baseClassObject(corePath, widgetObject.baseType);

                if (debug) {
                    grunt.log.writeln('name:' + widgetObject.name);
                    grunt.log.writeln('qualifiedName:' + widgetObject.qualifiedName);
                    _writeFile(_modulePath.resolve('/Temp/mvLog/keyboardWidget.json'), JSON.stringify(widgetObject));
                    _writeFile(_modulePath.resolve('/Temp/mvLog/baseClassObject.json'), JSON.stringify(baseClassObject));
                }

                // validate number of elements
                var result = elemValidator.validate(xmlObj, keyboardType);
                if (result.success !== true) {
                    grunt.fail.fatal('Error at XML validation: ' + result.err);
                }

                // json of base class widget (=complete widget info, generated by widget compiler)
                var baseClassWidget = grunt.file.readJSON(_modulePath.resolve(baseClassObject.metaDir, baseClassObject.name + '.json'));

                // json of keyboardWidget as result of baseClassWidget patched with additional info and not as result of a widget compiler
                var widgetInfo = patchKeyboard.run(baseClassWidget, widgetObject, grunt, debug);

                _writeFile(widgetObject.metaClassPath + '.json', JSON.stringify(widgetInfo));

                var cssClassName;

                if (keyboardType === 'NumPad') {
                    cssClassName = 'brease_' + widgetObject.qualifiedName.replace(/\//g, '_');
                    // widget html file
                    // xsltTrans arguments: destPath, transPath, srcPath, parameter
                    xsltTrans.transform(grunt, _modulePath.resolve(widgetObject.dir, widgetObject.name + '.html'), _modulePath.resolve(grunt.config('basePath'), 'transformation/NumPadHTML.xsl'), srcFile, [{
                        name: 'qualifiedName',
                        value: widgetObject.qualifiedName
                    }, {
                        name: 'widgetName',
                        value: widgetObject.name
                    }, {
                        name: 'cssClassName',
                        value: cssClassName
                    }]);

                    // widget scss file
                    xsltTrans.transform(grunt, _modulePath.resolve(widgetObject.dir, 'css/' + widgetObject.name + '.scss'), _modulePath.resolve(grunt.config('basePath'), 'transformation/NumPadCSS.xsl'), srcFile, [{
                        name: 'cssClassName',
                        value: cssClassName
                    }, {
                        name: 'widgetName',
                        value: widgetObject.name
                    }]);
                } else {

                    cssClassName = 'brease_' + widgetObject.qualifiedName.replace(/\//g, '_');
                    // widget html file
                    // xsltTrans arguments: destPath, transPath, srcPath, parameter
                    xsltTrans.transform(grunt, _modulePath.resolve(widgetObject.dir, widgetObject.name + '.html'), _modulePath.resolve(grunt.config('basePath'), 'transformation/AlphaPadHTML.xsl'), srcFile, [{
                        name: 'qualifiedName',
                        value: widgetObject.qualifiedName
                    }, {
                        name: 'widgetName',
                        value: widgetObject.name
                    }, {
                        name: 'cssClassName',
                        value: cssClassName
                    }]);

                    //// widget scss file
                    xsltTrans.transform(grunt, _modulePath.resolve(widgetObject.dir, 'css/' + widgetObject.name + '.scss'), _modulePath.resolve(grunt.config('basePath'), 'transformation/AlphaPadCSS.xsl'), srcFile, [{
                        name: 'cssClassName',
                        value: cssClassName
                    }, {
                        name: 'widgetName',
                        value: widgetObject.name
                    }]);
                }

                // widget js file
                var templateJS = grunt.file.read(grunt.config('basePath') + '/templates/' + baseClassObject.name + 'Template.js'),
                    widgetJS = keyboardJsPrepare.createWidgetJS(templateJS, widgetObject, baseClassObject);
                _writeFile(_modulePath.resolve(widgetObject.dir, widgetObject.name + '.js'), widgetJS);

                // widget style file
                var templateStyle = grunt.file.read(grunt.config('basePath') + '/templates/' + baseClassObject.name + 'Template.style'),
                    widgetStyle = _createWidgetStyle(templateStyle, widgetObject, widgetObject.commonProps);
                _writeFile(widgetObject.metaClassPath + '.style', widgetStyle);
                var widgetStyleObj = styleParser.parseXML(widgetStyle);
                var ar = widgetStyleObj.styleProperties.StyleProperty;
                for (var i = ar.length - 1; i >= 0; i -= 1) {
                    if (ar[i]['$'].name === 'width' || ar[i]['$'].name === 'height') {
                        ar.splice(i, 1);
                    }
                }
                widgetInfo.styleproperties = widgetStyleObj.styleProperties;

                // from here, the keyboard build corresponds to the widget build

                // meta infos for use in JS
                var additionalMeta = { keyboard: { type: widgetObject.keyboardType } };
                if (displayName) {
                    additionalMeta.keyboard.displayName = displayName;
                }
                var classInfo = jsPrepare.run(widgetInfo, widgetObject.qualifiedName, baseClassObject.type, false, additionalMeta);
                _writeFile(_modulePath.resolve(widgetObject.dir, 'designer/ClassInfo.js'), classInfo);

                // remove non-public properties and related events
                // we have to do this after creation of ClassInfo and Widget.js, because we need them in the widget but not in the interface to AS
                _removeNonPublic(widgetInfo, ['events', 'properties']);

                // widget xsd file
                var widgetXsd = xsdPrepare.run(widgetInfo, {
                    prettify: true
                }, DataTypes, Properties);
                _writeFile(widgetObject.metaClassPath + '.xsd', widgetXsd);

                //styles of the base class widget as an JS object extracted from .widget file {styleProperties.StyleProperty:[],propertyGroups}                
                var superStyleObj = styleParser.parseFile(baseClassObject.dir + '/meta/' + baseClassObject.name + '.widget', grunt);

                var styleProperties = styleParser.merge(widgetInfo.name, superStyleObj.styleProperties, widgetStyleObj.styleProperties);

                if (debug) {
                    _writeFile(_modulePath.resolve('/Temp/mvLog/widgetStyleObj.json'), JSON.stringify(widgetStyleObj));
                    _writeFile(_modulePath.resolve('/Temp/mvLog/styleProperties.xml'), styleProperties);
                }

                // this method creates the xml of stylable properties for the .widget file
                // and sets default values in superStyle if they exist in compoundWidget
                var stylablePropsXML = _createStyleXML(superStyleObj, widgetObject);

                // widget xml (.widget file)
                var widgetXMLFile = widgetObject.metaClassPath + '.widget',
                    widgetXML = _createWidgetFile(widgetInfo, json2xml, stylablePropsXML, superStyleObj.propertyGroups);

                _writeFile(widgetXMLFile, widgetXML);

                // widget styles xsd file
                var stylesXsd = xsdPrepare.runWidgetStyleDefinition(widgetInfo, {
                    prettify: true
                });
                if (stylesXsd !== undefined && stylesXsd !== '') {
                    _writeFile(widgetObject.metaClassPath + '_Styles.xsd', stylesXsd);
                } else {
                    _deleteFile(widgetObject.metaClassPath + '_Styles.xsd');
                }

                // widget events/actions xsd file
                var eventActionXsd = xsdPrepare.runEventActionDefinition(widgetInfo, {
                    prettify: true
                }, DataTypes);
                if (eventActionXsd !== undefined && eventActionXsd !== '') {
                    _writeFile(widgetObject.metaClassPath + '_EventsActions.xsd', eventActionXsd);
                } else {
                    _deleteFile(widgetObject.metaClassPath + '_EventsActions.xsd');
                }

                // base and default scss files
                xsltTrans.transform(grunt, widgetObject.metaClassPath + '_default.scss', _modulePath.resolve(grunt.config('basePath'), 'transformation/DefaultStyleTransformation.xsl'), widgetXMLFile, [{
                    name: 'fileType',
                    value: 'scss'
                }]);
                xsltTrans.transform(grunt, widgetObject.metaClassPath + '_base.scss', _modulePath.resolve(grunt.config('basePath'), 'transformation/DefaultStyleTransformation.xsl'), widgetXMLFile, [{
                    name: 'fileType',
                    value: 'scss'
                }, {
                    name: 'createBase',
                    value: true
                }]);

                grunt.config.set('sass.options.includePaths', [_modulePath.resolve(corePath, 'css/libs'), coreWidgets]);

                // default css file                
                grunt.config.set('sass.keyboardDefault.src', _modulePath.resolve(widgetObject.metaDir, widgetObject.name + '_default.scss'));
                grunt.config.set('sass.keyboardDefault.dest', _modulePath.resolve(widgetObject.metaDir, widgetObject.name + '_default.sass.css'));

                // widget css file
                grunt.config.set('sass.keyboardWidget.src', _modulePath.resolve(widgetObject.dir, 'css/' + widgetObject.name + '.scss'));
                grunt.config.set('sass.keyboardWidget.dest', _modulePath.resolve(widgetObject.dir, 'css/' + widgetObject.name + '.sass.css'));

                grunt.task.run(['sass:keyboardDefault', 'sass:keyboardWidget']);
            }
        });

    });

    function _createStyleXML(superStyle, widgetObject) {
        // set default values if they exist in keyboardWidget
        for (var i = 0; i < superStyle.styleProperties.StyleProperty.length; i += 1) {
            var prop = superStyle.styleProperties.StyleProperty[i]['$'],
                propName = prop['name'];
            if (widgetObject.commonProps !== undefined && widgetObject.commonProps[propName] !== undefined && ['width', 'height', 'top', 'left', 'zIndex'].indexOf(propName) === -1) {
                prop.default = widgetObject.commonProps[propName];
                prop.owner = widgetObject.type;
            }
        }
        var styleXML = _xmlConvert.js2xml({
            StyleProperties: superStyle.styleProperties
        });

        return styleXML;
    }

    function _createWidgetFile(widgetInfo, json2xml, stylablePropsXML, propertyGroupsObj) {

        // remove not_styleable properties from normal properties
        if (Array.isArray(widgetInfo.properties)) {

            for (var i = widgetInfo.properties.length - 1; i >= 0; i -= 1) {
                var property = widgetInfo.properties[i];
                if (property.cssProp === true) {
                    widgetInfo.properties.splice(i, 1);
                } else {
                    if (property.setAction) {
                        delete property.setAction;
                    }
                    if (property.getAction) {
                        delete property.getAction;
                    }
                }

            }
        }

        // generate xml from widgetInfo
        var xml = json2xml.convert(widgetInfo, {
            prettify: {
                enable: true
            }
        });

        // adding styleable properties and propertyGroups to xml
        var groupXml = _xmlConvert.js2xml({
            PropertyGroups: propertyGroupsObj
        });

        var insertIndex = xml.lastIndexOf('</Widget>');
        xml = xml.substring(0, insertIndex) + ((propertyGroupsObj) ? groupXml + '\n' : '') + stylablePropsXML + '\n' + xml.substring(insertIndex);

        if (Array.isArray(widgetInfo.eventBindings) && Array.isArray(widgetInfo.eventBindings[0].EventBinding)) {
            var eventBindingXML = _xmlConvert.js2xml({
                EventBindings: widgetInfo.eventBindings[0]
            });
            insertIndex = xml.lastIndexOf('</Widget>');
            xml = xml.substring(0, insertIndex) + eventBindingXML + '\n' + xml.substring(insertIndex);
        }
        return xml;

    }

    function _removeNonPublic(widgetInfo, types) {
        var i;

        if (types.indexOf('properties') !== -1 && Array.isArray(widgetInfo.properties)) {
            for (i = widgetInfo.properties.length - 1; i >= 0; i -= 1) {
                var property = widgetInfo.properties[i];
                if (property.public === false) {
                    widgetInfo.properties.splice(i, 1);
                }
            }
        }
        if (types.indexOf('methods') !== -1 && Array.isArray(widgetInfo.methods)) {
            for (i = widgetInfo.methods.length - 1; i >= 0; i -= 1) {
                var method = widgetInfo.methods[i];
                if (method.public === false) {
                    widgetInfo.methods.splice(i, 1);
                }
            }
        }
        if (types.indexOf('events') !== -1 && Array.isArray(widgetInfo.events)) {
            for (i = widgetInfo.events.length - 1; i >= 0; i -= 1) {
                var event = widgetInfo.events[i];
                if (event.public === false) {
                    widgetInfo.events.splice(i, 1);
                }
            }
        }
    }

    function _createWidgetStyle(template, widgetObject, commonProps) {
        var newFile = template.replace('__WIDGET_NAME__', widgetObject.type);
        newFile = newFile.replace('__WIDTH__', commonProps.width);
        newFile = newFile.replace('__HEIGHT__', commonProps.height);

        return newFile;
    }

    function _baseClassObject(ROOT, baseType) {
        var obj = {
            type: 'system.widgets.' + baseType
        };
        obj.metaDir = _modulePath.resolve(ROOT, 'system/widgets/' + baseType + '/meta');
        obj.name = obj.type.substring(obj.type.lastIndexOf('.') + 1);
        obj.filePath = Utils.className2Path(obj.type);
        obj.qualifiedName = Utils.className2Path(obj.type, false, true);
        obj.dir = _modulePath.resolve(ROOT, 'system/widgets/' + baseType);
        return obj;
    }

    function _widgetObject(keyboardXML, keyboardType, ROOT, libraryName) {
        var obj = {
            name: keyboardXML['$']['id'],
            library: libraryName
        };
        obj.dir = _modulePath.resolve(ROOT, obj.library + '/' + obj.name); //           <%ROOT%>/widgetLibrary/widgetName
        obj.metaDir = _modulePath.resolve(obj.dir, 'meta'); //                          <%ROOT%>/widgetLibrary/widgetName/meta
        obj.metaClassPath = _modulePath.resolve(obj.metaDir, obj.name); //              <%ROOT%>/widgetLibrary/widgetName/meta/widgetName
        obj.qualifiedName = 'widgets/' + obj.library + '/' + obj.name; //               widgets/widgetLibrary/widgetName
        obj.filePath = 'widgets/' + obj.library + '/' + obj.name + '/' + obj.name; //   widgets/widgetLibrary/widgetName/widgetName
        obj.type = 'widgets.' + obj.library + '.' + obj.name; //                        widgets.widgetLibrary.widgetName
        obj.keyboardType = keyboardType;
        obj.baseType = (obj.keyboardType === 'NumPad') ? 'NumPad' : 'KeyBoard';

        obj.commonProps = {
            width: keyboardXML['$']['width'],
            height: keyboardXML['$']['height']
        };
        return obj;
    }

    function _writeFile(path, content) {
        if (debug) {
            grunt.log.writeln(('write ' + path).cyan);
        }
        grunt.file.write(path, content);
    }

    function _deleteFile(path) {
        if (grunt.file.exists(path)) {
            grunt.file.delete(path);
        }
    }

};
